///<reference path="./.d.ts"/>
"use strict";
const childProcess = require("./child-process");
const errors = require("./errors");
const common = require("./iphone-simulator-common");
const options = require("./options");
const path = require("path");
const simctl_1 = require("./simctl");
const utils = require("./utils");
const xcode = require("./xcode");
const _ = require("lodash");
const iphone_simulator_name_getter_1 = require("./iphone-simulator-name-getter");
const osenv = require("osenv");
class XCodeSimctlSimulator extends iphone_simulator_name_getter_1.IPhoneSimulatorNameGetter {
    constructor() {
        super();
        this.deviceLogChildProcess = null;
        this.isDeviceLogOperationStarted = false;
        this.defaultDeviceIdentifier = "iPhone 6";
        this.simctl = null;
        this.simctl = new simctl_1.Simctl();
    }
    getDevices() {
        return this.simctl.getDevices();
    }
    getSdks() {
        let devices = this.simctl.getDevices();
        return _.map(devices, device => {
            return {
                displayName: `iOS ${device.runtimeVersion}`,
                version: device.runtimeVersion
            };
        });
    }
    run(applicationPath, applicationIdentifier) {
        let device = this.getDeviceToRun();
        let currentBootedDevice = _.find(this.getDevices(), device => this.isDeviceBooted(device));
        if (currentBootedDevice && (currentBootedDevice.name.toLowerCase() !== device.name.toLowerCase() || currentBootedDevice.runtimeVersion !== device.runtimeVersion)) {
            this.killSimulator();
        }
        this.startSimulator(device);
        if (!options.skipInstall) {
            this.simctl.install(device.id, applicationPath);
        }
        let launchResult = this.simctl.launch(device.id, applicationIdentifier);
        if (options.logging) {
            this.printDeviceLog(device.id, launchResult);
        }
    }
    sendNotification(notification) {
        let device = this.getBootedDevice();
        if (!device) {
            errors.fail("Could not find device.");
        }
        this.simctl.notifyPost("booted", notification);
    }
    getApplicationPath(deviceId, applicationIdentifier) {
        return this.simctl.getAppContainer(deviceId, applicationIdentifier);
    }
    getInstalledApplications(deviceId) {
        return common.getInstalledApplications(deviceId);
    }
    installApplication(deviceId, applicationPath) {
        return this.simctl.install(deviceId, applicationPath);
    }
    uninstallApplication(deviceId, appIdentifier) {
        return this.simctl.uninstall(deviceId, appIdentifier, { skipError: true });
    }
    startApplication(deviceId, appIdentifier) {
        // simctl launch command does not launch the process immediately and we have to wait a little bit,
        // just to ensure all related processes and services are alive.
        const launchResult = this.simctl.launch(deviceId, appIdentifier);
        utils.sleep(0.5);
        return launchResult;
    }
    stopApplication(deviceId, appIdentifier, bundleExecutable) {
        try {
            let xcodeMajorVersion = null;
            try {
                const xcodeVersion = xcode.getXcodeVersionData();
                xcodeMajorVersion = +xcodeVersion.major;
            }
            catch (err) {
            }
            let resultOfTermination;
            if (xcodeMajorVersion && xcodeMajorVersion < 8) {
                // Xcode 7.x does not have support for `xcrun simctl terminate` command
                resultOfTermination = childProcess.execSync(`killall ${bundleExecutable}`, { skipError: true });
            }
            else {
                resultOfTermination = this.simctl.terminate(deviceId, appIdentifier);
            }
            // killall command does not terminate the processes immediately and we have to wait a little bit,
            // just to ensure all related processes and services are dead.
            // Same is valid for simctl terminate when Simulator's OS version is below 10.
            utils.sleep(0.5);
            return resultOfTermination;
        }
        catch (e) {
        }
    }
    printDeviceLog(deviceId, launchResult) {
        let pid = "";
        let deviceLogChildProcess;
        if (launchResult) {
            pid = launchResult.split(":")[1].trim();
        }
        if (!this.isDeviceLogOperationStarted) {
            deviceLogChildProcess = this.getDeviceLogProcess(deviceId);
            if (deviceLogChildProcess.stdout) {
                deviceLogChildProcess.stdout.on("data", this.logDataHandler.bind(this, pid));
            }
            if (deviceLogChildProcess.stderr) {
                deviceLogChildProcess.stderr.on("data", this.logDataHandler.bind(this, pid));
            }
        }
        return deviceLogChildProcess;
    }
    logDataHandler(pid, logData) {
        const dataAsString = logData.toString();
        if (pid) {
            if (dataAsString.indexOf(`[${pid}]`) > -1) {
                process.stdout.write(dataAsString);
            }
        }
        else {
            process.stdout.write(dataAsString);
        }
    }
    getDeviceLogProcess(deviceId, predicate) {
        if (!this.isDeviceLogOperationStarted) {
            const device = this.getDeviceFromIdentifier(deviceId);
            const deviceVersion = device ? device.runtimeVersion : "";
            const majorVersion = deviceVersion.split(".")[0];
            if (majorVersion && parseInt(majorVersion) >= 11) {
                this.deviceLogChildProcess = this.simctl.getLog(deviceId, predicate);
            }
            else {
                const logFilePath = path.join(osenv.home(), "Library", "Logs", "CoreSimulator", deviceId, "system.log");
                this.deviceLogChildProcess = require("child_process").spawn("tail", ['-f', '-n', '1', logFilePath]);
            }
            this.isDeviceLogOperationStarted = true;
        }
        return this.deviceLogChildProcess;
    }
    getDeviceToRun(device) {
        let devices = _.sortBy(this.simctl.getDevices(), (device) => device.runtimeVersion), sdkVersion = options.sdkVersion || options.sdk, deviceIdOrName = options.device;
        if (device && (device.sdkVersion || device.sdk)) {
            sdkVersion = device.sdkVersion || device.sdk;
        }
        if (device && device.id) {
            deviceIdOrName = device.id;
        }
        let result = _.find(devices, (device) => {
            if (sdkVersion && !deviceIdOrName) {
                return device.runtimeVersion === sdkVersion;
            }
            if (deviceIdOrName && !sdkVersion) {
                return device.name === deviceIdOrName || device.id === deviceIdOrName;
            }
            if (deviceIdOrName && sdkVersion) {
                return device.runtimeVersion === sdkVersion && (device.name === deviceIdOrName || device.id === deviceIdOrName);
            }
            if (!sdkVersion && !deviceIdOrName) {
                return this.isDeviceBooted(device);
            }
        });
        if (!result) {
            result = _.find(devices, (device) => device.name === this.defaultDeviceIdentifier);
        }
        if (!result) {
            result = _.last(devices);
        }
        return result;
    }
    isDeviceBooted(device) {
        return device.state === 'Booted';
    }
    getBootedDevice() {
        let devices = this.simctl.getDevices();
        return _.find(devices, device => this.isDeviceBooted(device));
    }
    getBootedDevices() {
        const devices = this.simctl.getDevices();
        return _.filter(devices, device => this.isDeviceBooted(device));
    }
    startSimulator(device) {
        // In case the id is undefined, skip verification - we'll start default simulator.
        if (device && device.id) {
            this.verifyDevice(device);
        }
        if (!device || !device.runtimeVersion || !device.fullId) {
            device = this.getDeviceToRun(device);
        }
        if (!this.isDeviceBooted(device)) {
            const isSimulatorAppRunning = this.isSimulatorAppRunning();
            const haveBootedDevices = this.haveBootedDevices();
            if (isSimulatorAppRunning) {
                // In case user closes simulator window but simulator app is still alive
                if (!haveBootedDevices) {
                    device = this.getDeviceToRun();
                }
                this.simctl.boot(device.id);
            }
            else {
                common.startSimulator(device.id);
            }
            common.startSimulator(device.id);
            // startSimulaltor doesn't always finish immediately, and the subsequent
            // install fails since the simulator is not running.
            // Give it some time to start before we attempt installing.
            utils.sleep(1);
        }
    }
    haveBootedDevices() {
        const bootedDevices = this.getBootedDevices();
        return bootedDevices && bootedDevices.length > 0;
    }
    isSimulatorAppRunning() {
        const simulatorAppName = "Simulator";
        try {
            const output = childProcess.execSync(`ps cax | grep -w ${simulatorAppName}`);
            return output.indexOf(simulatorAppName) !== -1;
        }
        catch (e) {
            return false;
        }
    }
    verifyDevice(device) {
        const availableDevices = this.getDevices();
        if (!_.find(availableDevices, { id: device.id }) && !_.find(availableDevices, { name: device.id })) {
            errors.fail(`No simulator image available for device identifier '${device.id}'.`);
        }
    }
    getDeviceFromIdentifier(deviceId) {
        const availableDevices = this.getDevices();
        return _.find(availableDevices, { id: deviceId });
    }
    killSimulator() {
        childProcess.execSync("pkill -9 -f Simulator");
    }
}
XCodeSimctlSimulator.DEVICE_IDENTIFIER_PREFIX = "com.apple.CoreSimulator.SimDeviceType";
exports.XCodeSimctlSimulator = XCodeSimctlSimulator;
//# sourceMappingURL=iphone-simulator-xcode-simctl.js.map